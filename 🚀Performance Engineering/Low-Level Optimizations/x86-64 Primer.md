> A CISC assembly language developed by Intel, used in most modern machines.

Your `C` source code is preprocessed, compiled, assembled, and then linked into machine code. This is then interpreted by the hardware when executed.

These can be manually invoked with `clang` using the flags: `-E`, `-S`, `-c`, and then `ld`. The intermediate files are `.c`, `.i`, `.s`, and then `.o`, which are linked.

==Assembly language== is a convenient symbolic representation of machine code.

> [!question]
> Why look at assembly?

Well, you can get a sense of what the compiler is actually doing. This lets you ensure your optimizations are working, or find bugs. You can also manually modify the assembly (hopefully not too necessary in modern day). This allows you to use intrinsics that the compiler might not know about.

## Components

We work with ==x86-64 assembly== in this class (unlike RISC-V which you might be familiar with from 6.191). Here is an example of some of the main components of the code:

![[x86.png|center|512]]

## Registers

x86 has tons of registers. Here is a table of some common ones:

![[registers.png|center|512]]

Registers are ==aliased==: different names may refer to the same bytes. For example, here is the layout of the `a` register: ^09df1a

![[register_aliasing.png|center|512]]

Historically, x86 worked with 16-bit words: the register is named `%ax` with a high half `%ah` and a low half `%al`. As computer words got longer, we have been treated with 32-bit `%eax` (extended) and finally 64-bit `%rax` (simply, register).

## Instructions

x86-64 uses a ==complex instruction set==. Instructions are still formatted as `<opcode> <operand_list>`, where the operands are comma-separated. All operands are sources, and one might also be the destination (usually the *last* one).

> [!example]
> `addl %edi, %ecx` adds the contents of the `%edi` destination index register into the `%ecx` counter register.

The `e` prefix of the registers indicates that these are 32-bit. This corresponds to the suffix of the instructions.

> [!idea] (Instruction suffixes)
> `b` for 8-bit bytes, `w` for 16-bit words (remember that x86 began as 16-bit), `l` (or `d`) for 32-bit long/double words, and `q` for 64-bit quadwords.
> 
> Meanwhile for floats we have `s`, `d`, and `l` for single, double, and extended precisions.

> [!warning] (Syntax differences)
> Annoyingly, there are two main syntaxes for x86: AT&T syntax and Intel syntax. Don't get confused!
> 
> AT&T syntax is generated by `clang`, `objdump`, and `perf`, and is used in 6.106 lectures. It places destinations as the *last* operand. Addressing is handled by parentheses. 
> 
> Intel syntax is used by Intel documentation. It places destinations as the *first* operand (like RISC-V). Addressing is handled by square brackets.

Here are some examples of common opcodes:

![[opcodes.png|center|512]]

## Addressing

There are three main ==direct addressing modes== in x86-64:

* **Immediate**: use the specified value, e.g. `movq $106, %rdi`.
* **Register**: use the value in the specified register, e.g. `movq %rcx, %rdi`.
* **Direct memory**: use the value at the specified memory address, e.g. `movq 0x106, %rdi`.

Note that `$` specifies immediates while naked values are addresses. There are also ==indirect addressing modes==:

* **Register indirect**: uses the value at the address stored in the specified register, e.g. `movq (%rax), %rdi`.
* **Register indexed**: same as above but with an offset added to the address, e.g. `movq 106(%rax), %rdi`. 

As a CISC architecture, x86-64 really has some crazy instructions. This is one of the most complicated ones, called the **base indexed scale displacement** addressing mode, e.g. `movq 106(%rdi, %rdx, 8), %rax`.

Here, `106` is the displacement, `%rdi` holds the base, `%rdx` holds the index, and `8` is the scale. This accesses the address `base + index * scale + displacement`.

> [!idea]
> Base indexed scale displacement addressing supports fast array indexing.

## Jumps

One interesting thing about how branch instructions are implemented in x86 is that conditional jumps/moves use a one- or two-character suffix to indicate the ==condition code== to use (e.g. `jge`). These depend on the result of the previous instruction that sets all the condition codes, held in the so-called `RFLAGS` register.

They also take a ==label== as an operand that identifies a location in the code to branch to. These can be symbols, exact addresses, or relative addresses. They can also take an indirect address as an operand.

---

**Next:** [[Computer Architecture]]