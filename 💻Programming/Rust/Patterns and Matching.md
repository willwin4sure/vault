> [!definition] (Rust pattern)
> A ==pattern== is special syntax in Rust for matching against the structure of types. 

They are some combination of the following:

* Literals,
* Destructured arrays, enums, structs, or tuples,
* Variables,
* Wildcards,
* Placeholders

For example, `x`, `(a, 3)`, and `Some(Color::Red)`. To use a pattern, it gets compared to some value. If the pattern matches the value, we use the value parts in our code (we've seen this before when talking about [[Control Flow by Matching|matching]]). 

## Where Patterns Can Be Used

You've already seen some of these examples.

### `match` Arms

These formally look like:

```
match VALUE {
	PATTERN => EXPRESSION,
	PATTERN => EXPRESSION,
	PATTERN => EXPRESSION,
}
```
For example:
```rust
match x {
	None => None,
	Some(i) => Some(i + 1),
}
```

These need to be exhaustive. Using `_` will match anything (and ignore it), so it can be used as the last arm.

### Conditional `if let` Expressions

Equivalent to a match that only accepts a single case. You can combine these with `else if` and `else if let` statements too:

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {color}, as the background");
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}
```
Note that the new shadowed `age` generated by `Ok(age) = age` can't be used immediately, so you can't write something like `if let Ok(age) = age && age > 30`.

### `while let` Conditional Loops

Similar to the above:

```rust
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
	println!("{top}");
}
```

### `for` Loops

The value right after `for` is a pattern. You can use this to destructure tuples, for example:

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
	println!("{value} is at index {index}");
}
```

### `let` Statements

Every time you use a `let` statement, it actually looks like:

```
let PATTERN = EXPRESSION;
```

So you can do something like

```rust
let (x, y, z) = (1, 2, 3);
```

### Function Parameters

Yes, these can also be patterns. For example:

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

## Refutability

> [!definition] (Refutability)
> A pattern in Rust is ==irrefutable== if it matches any possible value that is passed in (of the appropriate type). Otherwise, it is called ==refutable==. 

For example, `x` is irrefutable while `Some(x)` is refutable (in case the value is `None`).

Function parameters, `let` statements, and `for` loops only accept irrefutable patterns, since they can't do anything meaningful if there is no match. `if let` and `while let` accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns (if it's irrefutable, why are you using a conditional at all?).

## Pattern Syntax

We gather all the syntax valid in patterns.

TODO

---

**Next:** [[Unsafe Rust]]